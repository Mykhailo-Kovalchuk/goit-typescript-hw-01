// ТИПІЗАЦІЯ ПРОСТИХ ТИПІВ ДАНИХ
// явна типізація. через двокрпку прописуємо явно який тип даних очікуємо
let total: number = 100;
let firstName: string = "Bobo";
let isActive: boolean = false;

let empty: null = null;
let undef: undefined = undefined; 

// неявна типізація. через двокрпку НЕ прописуємо явно який тип даних очікуємо, але TS під капотом собі сам присвоїть правильний тип (розкоментовуючи бачимо помилку)
let age = 10;
// age = "123"
// Неявна типізація на всі 100% надійна, тому краще завжи прописувати явно 


// ТИПІЗАЦІЯ СКЛАДНИХ ТИПІВ ДАНИХ
// Масиви
const numbers = [1, 2, 3, 4, "50", false];    // очікуємо масив чисел (якщо явно не вказати типізацію і передати різні типи даних, ts не зрозуміє що там повинно бути)
// const numbers: number[] = [1, 2, 3, 4, "50", false];  // розкоментуй і буде помилка
const numbersArr: number[] = [1, 2, 3, 4, 5] // тепер все гуд.
// якщо є помилка з типізацією методи масиву не спрацюють.
// numbersArr.push('12'); // очікуючи рядок ми не можемо додати його в масив чисел // розкоментуй і буде помилка

// Об`єкти
// для роботи з об`єктом використовуємо type

const user = {  // TS Не розуміє як типізувати дані в такому складному типі даних як об`єкт, тому що тут якраз можлива їх велика кількість. Треба явно вказувати що очікує кожен ключ.
    name: "Bob",
    age: 12
}

const userTS: {name: string, age: number } = { // Ось так правильно
    name: "Bobby",
    age: 20
}
// userTS.name = 123; // при перевизначенні на неправильний тип даних буде падати помилка.
// userTS.age = "Eleven"

// const userTS: {name: string, age: number } = {.......... } - не зручно читати типізацію яку задаємо при оголошенні змінної. 
// Тому типи даних переважно виносяться окремо - оголошується така змінна не через const/let, а через type
type User = {
name: string,
age: number}

const userTS2: User = { // запис в результаті виглядає ось так 
    name: "Ann",
    age: 30
}







function add(num1: number, num2: number) {
    return num1 + num2;
  }
  
  add(1, 1);
